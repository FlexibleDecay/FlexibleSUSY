// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_decays.hpp
 *
 * @brief contains class for calculating particle decays
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ (git commit: @FlexibleSUSYGitCommit@) and SARAH @SARAHVersion@ .
 */

#ifndef @ModelName@_DECAYS_H
#define @ModelName@_DECAYS_H

#include "@ModelName@_decay_table.hpp"
#include "@ModelName@_mass_eigenstates.hpp"
#include "cxx_qft/@ModelName@_qft.hpp"

#include "decay_amplitudes.hpp"
#include "decays_loop_corrections.hpp"
#include "decays_problems.hpp"
#include "effective_couplings.hpp"
#include "lowe.h"

namespace flexiblesusy {

class @ModelName@_mass_eigenstates;

template <typename Field1, typename Field2>
double
final_state_symmetry_factor(typename cxx_qft::field_indices<Field1>::type const& idx1,
                            typename cxx_qft::field_indices<Field2>::type const& idx2)
{
   if (std::is_same<Field1, Field2>::value) {
      // TODO: we also compare if (potential) color indices are the same,
      //       this might cause problems if someone accidentaly initializes them
      //       differently
      if (boost::range::equal(idx1, idx2)) {
         return 0.5;
      }
   }
   return 1.;
}

class @ModelName@_decays {
public:
   @ModelName@_decays() = default;
   @ModelName@_decays(const @ModelName@_mass_eigenstates& model_, softsusy::QedQcd const& qedqcd_)
      : model(model_)
      , qedqcd(qedqcd_)
      {}
   @ModelName@_decays(const @ModelName@_mass_eigenstates& model_, softsusy::QedQcd const& qedqcd_, bool corrections)
      : model(model_)
      , qedqcd(qedqcd_)
      , include_higher_order_corrections(corrections)
      {}
   @ModelName@_decays(const @ModelName@_decays&) = default;
   @ModelName@_decays(@ModelName@_decays&&) = default;
   ~@ModelName@_decays() = default;
   @ModelName@_decays& operator=(const @ModelName@_decays&) = default;
   @ModelName@_decays& operator=(@ModelName@_decays&&) = default;

   void set_include_higher_order_corrections(bool);
   void set_loop_corrections(const Decays_loop_corrections&);
   const Decays_loop_corrections& get_loop_corrections() const;
   const @ModelName@_decay_table& get_decay_table() const;
   const Decays_problems& get_problems() const;

   void clear();
   void clear_problems();
   void calculate_decays();

@decaysGetters@
@decaysCalculationPrototypes@

@partialWidthCalculationPrototypes@

private:
   @ModelName@_mass_eigenstates model{};
   softsusy::QedQcd qedqcd{};
   bool include_higher_order_corrections{true};
   bool run_to_decay_particle_scale{true};
   @ModelName@_decay_table decay_table{};
   Decays_loop_corrections loop_corrections{};
   Decays_problems problems{};

   template<typename FieldIn, typename FieldOut1, typename FieldOut2>
   typename Decay_amplitude_type<FieldIn, FieldOut1, FieldOut2>::type
   effective_coupling(
      const cxx_qft::@ModelName@_evaluation_context&,
      const typename cxx_qft::field_indices<FieldIn>::type&,
      const typename cxx_qft::field_indices<FieldOut1>::type&,
      const typename cxx_qft::field_indices<FieldOut2>::type&) const;

   template<typename FieldIn, typename FieldOut1, typename FieldOut2>
   double get_partial_width(
      const cxx_qft::@ModelName@_evaluation_context&,
      typename cxx_qft::field_indices<FieldIn>::type const&,
      typename cxx_qft::field_indices<FieldOut1>::type const&,
      typename cxx_qft::field_indices<FieldOut2>::type const&) const;
};

template<typename FieldIn, typename FieldOut1, typename FieldOut2>
typename Decay_amplitude_type<FieldIn, FieldOut1, FieldOut2>::type
@ModelName@_decays::effective_coupling(
   const cxx_qft::@ModelName@_evaluation_context& context,
   const typename cxx_qft::field_indices<FieldIn>::type& indexIn,
   const typename cxx_qft::field_indices<FieldOut1>::type& indexOut1,
   const typename cxx_qft::field_indices<FieldOut2>::type& indexOut2) const
{
   const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   const auto vertex =
      cxx_qft::Vertex<FieldIn, FieldOut1, FieldOut2>::evaluate(
         indices, context);

   const auto m_decay = context.mass<FieldIn>(indexIn);
   const auto m_out_1 = context.mass<FieldOut1>(indexOut1);
   const auto m_out_2 = context.mass<FieldOut2>(indexOut2);

   return tree_level_decay_amplitude<FieldIn, FieldOut1, FieldOut2>(m_decay, m_out_1, m_out_2, vertex);
}

@effectiveCouplingsSpecializationDecls@

// template<>
// Decay_amplitude_SVV
// @ModelName@_decays::effective_coupling<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@GluonName@, cxx_qft::@ModelName@_fields::@GluonName@>(
//    const cxx_qft::@ModelName@_evaluation_context&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@GluonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@GluonName@>::type&
//    ) const;

// template<>
// Decay_amplitude_SVV
// @ModelName@_decays::effective_coupling<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@PhotonName@, cxx_qft::@ModelName@_fields::@PhotonName@>(
//    const cxx_qft::@ModelName@_evaluation_context&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type&
//    ) const;

// template<>
// Decay_amplitude_SVV
// @ModelName@_decays::effective_coupling<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@PhotonName@, cxx_qft::@ModelName@_fields::@ZBosonName@>(
//    const cxx_qft::@ModelName@_evaluation_context&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@ZBosonName@>::type&
//    ) const;

// template<>
// Decay_amplitude_SVV
// @ModelName@_decays::effective_coupling<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@ZBosonName@, cxx_qft::@ModelName@_fields::@PhotonName@>(
//    const cxx_qft::@ModelName@_evaluation_context&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@ZBosonName@>::type&,
//    const typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type&
//    ) const;

// S -> FF
template <typename Field1, typename Field2, typename Field3>
typename std::enable_if<cxx_qft::is_scalar<Field1>::value &&
                        cxx_qft::is_fermion<Field2>::value &&
                        cxx_qft::is_fermion<Field3>::value,
                        double>::type
amplitude_squared(cxx_qft::@ModelName@_evaluation_context const& context,
                  typename cxx_qft::field_indices<Field1>::type const& indexIn,
                  typename cxx_qft::field_indices<Field2>::type const& indexOut1,
                  typename cxx_qft::field_indices<Field3>::type const& indexOut2)
{
   // const auto mA = context_.mass<Field1>(indexIn);
   // const auto muB = context_.mass<Field2>(indexOut1) / mA;
   // const auto muC = context_.mass<Field2>(indexOut2) / mA;

   // const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   // const auto vertex = Vertex<Field1,Field2,Field3>::evaluate(indices, context_);

   // const auto L = vertex.left();
   // const auto R = vertex.right();

   // // eq. B.35b
   // return mA * mA *
   //        ((std::norm(L) + std::norm(R)) * (1. - muB * muB - muC * muC) -
   //         2. * muB * muC * 2. * std::real(std::conj(L) * R) );

   Decay_amplitude_SFF amplitude;
   amplitude.m_decay = context.mass<Field1>(indexIn);
   amplitude.m_out_1 = context.mass<Field2>(indexOut1);
   amplitude.m_out_2 = context.mass<Field3>(indexOut2);

   const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   const auto vertex = cxx_qft::Vertex<Field1,Field2,Field3>::evaluate(indices, context);

   // @todo correct assignments
   amplitude.matrix_element_left = vertex.left();
   amplitude.matrix_element_right = vertex.right();

   return amplitude.square();
}

// S -> VV
template<typename Field1, typename Field2, typename Field3>
typename std::enable_if<cxx_qft::is_scalar<Field1>::value &&
                        cxx_qft::is_vector<Field2>::value &&
                        cxx_qft::is_vector<Field3>::value, double>::type
amplitude_squared(cxx_qft::@ModelName@_evaluation_context const& context,
                  typename cxx_qft::field_indices<Field1>::type const& indexIn,
                  typename cxx_qft::field_indices<Field2>::type const& indexOut1,
                  typename cxx_qft::field_indices<Field3>::type const& indexOut2)
{
   // const auto mA = context_.mass<Field1>(indexIn);
   // double res;
   // // B.37
   // if(Field2::massless && Field3::massless) {
   //    res = 4.;
   // } else if((Field2::massless && !Field3::massless) || (!Field2::massless && Field3::massless)) {
   //    res = 3.;
   // } else {
   //    const auto muB2 = pow(context_.mass<Field2>(indexOut1) / mA, 2);
   //    const auto muC2 = pow(context_.mass<Field2>(indexOut2) / mA, 2);
   //    res = 1./(4.*muB2*muC2) * (
   //       pow(muB2 + muC2, 2) - 2.*(muB2 + muC2) + 8.*muB2*muC2 + 1
   //    );
   // }
   // const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   // const auto vertex = Vertex<Field1,Field2,Field3>::evaluate(indices, context_);
   // return res * std::norm(vertex.value());

   const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   const auto vertex = cxx_qft::Vertex<Field1,Field2,Field3>::evaluate(indices, context);

   if (Field2::massless && Field3::massless) {
      return 4. * AbsSqr(vertex.value());
   } else if ((Field2::massless && !Field3::massless) ||
              (!Field2::massless && Field3::massless)) {
      return 3. * AbsSqr(vertex.value());
   }

   Decay_amplitude_SVV amplitude;
   amplitude.m_decay = context.mass<Field1>(indexIn);
   amplitude.m_out_1 = context.mass<Field2>(indexOut1);
   amplitude.m_out_2 = context.mass<Field3>(indexOut2);

   amplitude.M1 = vertex.value();
   amplitude.M2 = std::complex<double>(0., 0.);

   return amplitude.square();
}
// S -> S V
template <typename Field1, typename Field2, typename Field3>
typename std::enable_if<cxx_qft::is_scalar<Field1>::value &&
                        cxx_qft::is_scalar<Field2>::value &&
                        cxx_qft::is_vector<Field3>::value,
                        double>::type
amplitude_squared(cxx_qft::@ModelName@_evaluation_context const& context,
                  typename cxx_qft::field_indices<Field1>::type const& indexIn,
                  typename cxx_qft::field_indices<Field2>::type const& indexOut1,
                  typename cxx_qft::field_indices<Field3>::type const& indexOut2)
{
   // const auto mA2 = pow(context_.mass<Field1>(indexIn), 2);
   // const auto muB2 = pow(context_.mass<Field2>(indexOut1), 2) / mA2;

   // double result;
   // // B.36
   // if (Field3::massless) {
   //    result = -2. * mA2 * (1 + muB2);
   // } else {
   //    const auto muC2 = pow(context_.mass<Field2>(indexOut2), 2) / mA2;
   //    result = mA2/muC2 * (pow(muC2 - muB2, 2) -2. * (muB2 + muC2) + 1.);
   // }
   // const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   // const auto vertex = Vertex<Field1,Field2,Field3>::evaluate(indices, context_);
   // return result * std::norm(vertex.value(1,2));

   const auto indices = concatenate(indexIn, indexOut1, indexOut2);
   const auto vertex = cxx_qft::Vertex<Field1,Field2,Field3>::evaluate(indices, context);

   if (Field3::massless) {
      const auto mA2 = Sqr(context.mass<Field1>(indexIn));
      const auto muB2 = Sqr(context.mass<Field2>(indexOut1)) / mA2;

      return -2. * mA2 * (1. + muB2) * AbsSqr(vertex.value(1, 2));
   }

   Decay_amplitude_SSV amplitude;
   amplitude.m_decay = context.mass<Field1>(indexIn);
   amplitude.m_scalar = context.mass<Field2>(indexOut1);
   amplitude.m_vector = context.mass<Field3>(indexOut2);

   amplitude.matrix_element = vertex.value(1, 2);

   return amplitude.square();
}
// S -> V S
template<typename Field1, typename Field2, typename Field3>
typename std::enable_if<cxx_qft::is_scalar<Field1>::value &&
                        cxx_qft::is_scalar<Field3>::value &&
                        cxx_qft::is_vector<Field2>::value, double>::type
amplitude_squared(cxx_qft::@ModelName@_evaluation_context const& context,
                  typename cxx_qft::field_indices<Field1>::type const& indexIn,
                  typename cxx_qft::field_indices<Field2>::type const& indexOut1,
                  typename cxx_qft::field_indices<Field3>::type const& indexOut2)
{
      return amplitude_squared<Field1, Field3, Field2>(context, indexIn, indexOut2, indexOut1);
}

// S -> SS
template<typename Field1, typename Field2, typename Field3>
typename std::enable_if<cxx_qft::is_scalar<Field1>::value &&
                        cxx_qft::is_scalar<Field2>::value &&
                        cxx_qft::is_scalar<Field3>::value, double>::type
amplitude_squared(cxx_qft::@ModelName@_evaluation_context const& context,
                  typename cxx_qft::field_indices<Field1>::type const& indexIn,
                  typename cxx_qft::field_indices<Field2>::type const& indexOut1,
                  typename cxx_qft::field_indices<Field3>::type const& indexOut2)
{
      // const auto indices = concatenate(indexIn, indexOut1, indexOut2);
      // const auto vertex = Vertex<Field1,Field2,Field3>::evaluate(indices, context_);
      // // eq. B.35b
      // return std::norm(vertex.value());

      const auto indices = concatenate(indexIn, indexOut1, indexOut2);
      const auto vertex = cxx_qft::Vertex<Field1,Field2,Field3>::evaluate(indices, context);

      Decay_amplitude_SSS amplitude;
      amplitude.matrix_element = vertex.value();

      return amplitude.square();
}
// generic decay of FieldIn -> FieldOut1 FieldOut2
template<typename FieldIn, typename FieldOut1, typename FieldOut2>
double @ModelName@_decays::get_partial_width(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<FieldIn>::type const& indexIn,
   typename cxx_qft::field_indices<FieldOut1>::type const& indexOut1,
   typename cxx_qft::field_indices<FieldOut2>::type const& indexOut2
   ) const
{
   using effective_couplings::beta;

   // phase space without symmetry factor
   const double mIn = context.physical_mass<FieldIn>(indexIn);
   const double mOut1 = context.physical_mass<FieldOut1>(indexOut1);
   const double mOut2 = context.physical_mass<FieldOut2>(indexOut2);

   const double ps = 1./(8.*Pi) * beta(mIn, mOut1, mOut2);

   // phase space symmetry factor
   const double ps_symmetry =
      final_state_symmetry_factor<FieldOut1, FieldOut2>(indexOut1, indexOut2);

   // matrix element squared
   const auto mat_elem = effective_coupling<FieldIn, FieldOut1, FieldOut2>(
      context, indexIn, indexOut1, indexOut2);
   const auto mat_elem_sq = mat_elem.square();

   // flux * phase space factor * symmetry factor * matrix element^2
   return 0.5 * ps * ps_symmetry * mat_elem_sq / mIn;
}

// explicit specializations

@declarations@

/*
template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@ZBosonName@, cxx_qft::@ModelName@_fields::@ZBosonName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@ZBosonName@>::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@ZBosonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@WBosonName@, cxx_qft::conj<cxx_qft::@ModelName@_fields::@WBosonName@>::type>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::conj<cxx_qft::@ModelName@_fields::@WBosonName@> >::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@WBosonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@GluonName@, cxx_qft::@ModelName@_fields::@GluonName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@GluonName@>::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@GluonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@PhotonName@, cxx_qft::@ModelName@_fields::@PhotonName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@PhotonName@, cxx_qft::@ModelName@_fields::@ZBosonName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@ZBosonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@ZBosonName@, cxx_qft::@ModelName@_fields::@PhotonName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@ZBosonName@>::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@PhotonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::@ModelName@_fields::@HiggsBosonName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::conj<cxx_qft::@ModelName@_fields::@DownQuarkName@>::type, cxx_qft::@ModelName@_fields::@DownQuarkName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::conj<cxx_qft::@ModelName@_fields::@DownQuarkName@> >::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@DownQuarkName@>::type const& indexOut2
   ) const;

template<>
double @ModelName@_decays::get_partial_width<cxx_qft::@ModelName@_fields::@HiggsBosonName@, cxx_qft::conj<cxx_qft::@ModelName@_fields::@UpQuarkName@>::type, cxx_qft::@ModelName@_fields::@UpQuarkName@>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@HiggsBosonName@>::type const& indexIn,
   typename cxx_qft::field_indices<cxx_qft::conj<cxx_qft::@ModelName@_fields::@UpQuarkName@> >::type const& indexOut1,
   typename cxx_qft::field_indices<cxx_qft::@ModelName@_fields::@UpQuarkName@>::type const& indexOut2
   ) const;
*/
} // namespace flexiblesusy

#endif
