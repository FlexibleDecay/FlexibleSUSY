#ifndef H_FS_QFT_CALCULATIONS
#define H_FS_QFT_CALCULATIONS

#include "@ModelName@_qft.hpp"
#include "@ModelName@_vertices.hpp"

#include <Eigen/Core>

#include <boost/mpl/map.hpp>
#include <boost/mpl/pair.hpp>
#include <boost/mpl/apply.hpp>
#include <boost/mpl/vector.hpp>
#include <boost/mpl/zip_view.hpp>
#include <boost/mpl/for_each.hpp>
#include <boost/mpl/transform.hpp>
#include <boost/mpl/unpack_args.hpp>
#include <boost/mpl/placeholders.hpp>
#include <boost/mpl/front_inserter.hpp>

#include <boost/fusion/include/map.hpp>
#include <boost/fusion/adapted/mpl.hpp>
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/include/make_vector.hpp>
#include <boost/fusion/functional/adapter/fused.hpp>

#include <boost/functional/value_factory.hpp>

namespace flexiblesusy
{
namespace cxx_qft
{
namespace calculations
{
namespace detail
{
  struct metafunction_class_mpl_map
  {
    template<class ...Args>
    struct apply
    {
      using type = boost::mpl::map<Args...>;
    };
  };

  struct metafunction_class_fusion_map
  {
    template<class ...Args>
    struct apply
    {
      using type = boost::fusion::map<Args...>;
    };
  };

  template<
    class GenericKeys,
    template<typename> class F,
    class StateVector
  > class accumulate_generic_impl
  {
    std::array<std::complex<double>, 12> &value;
    StateVector state;
  
  public:
    template<class ...Args>
    accumulate_generic_impl( std::array<std::complex<double>, 12> &v,
        Args && ...args )
    : value( v ), state( std::forward<Args>( args )... )
    {}
  
    template<class InsertionData>
    void operator()( InsertionData )
    {
      using namespace boost::mpl;

      using field_insertions = typename at_c<InsertionData, 0>::type;
      static constexpr int combinatorial_factor =
        at_c<InsertionData, 1>::type::value;

      using colour_factor_ratio = typename at_c<InsertionData, 2>::type;

      constexpr double colour_factor = double(colour_factor_ratio::num) /
        double(colour_factor_ratio::den);
      
      using pairs = typename transform<
        GenericKeys,
        field_insertions,
        quote2<pair>,
        front_inserter<vector<>>
      >::type;

      using GenericFieldMap = typename apply<
        unpack_args<metafunction_class_mpl_map>,
        pairs
      >::type;
    
      const auto value_boost = boost::fusion::fused<boost::value_factory<F<GenericFieldMap>>
      >{}( state )();

      for ( std::size_t i=0; i<value.size(); i++ ) {
        value.at(i) += colour_factor * combinatorial_factor * value_boost.at(i);
      }
    }
  };

  template<
    class GenericFieldKeys,
    template<typename> class F,
    class ...Args
  > accumulate_generic_impl<
    GenericFieldKeys, F,
    typename boost::fusion::result_of::make_vector<Args...>::type
  > make_accumulate_generic_impl( std::array<std::complex<double>, 12> &v,
      Args &&... args )
  {
    return accumulate_generic_impl<
      GenericFieldKeys, F,
      typename boost::fusion::result_of::make_vector<Args...>::type
    >{ v, std::forward<Args>( args )... };
  }

  template<class GenericFieldKey> struct field_vector
  {
    using type = typename GenericFieldKey::field_vector;
  };
}

struct lorentz_scalar {};
struct lorentz_left {};
struct lorentz_right {};
struct lorentz_momentum_diff
{
  int minuend_index;
  int subtrahend_index;
};
struct lorentz_inverse_metric {};

struct generic_context : @ModelName@_evaluation_context
{
  using @ModelName@_evaluation_context::@ModelName@_evaluation_context;
 
  template<class ...Fields>
  std::complex<double> vertex( 
    lorentz_scalar,
    const typename Vertex<Fields...>::indices_type &indices
  ) const
  {
    return Vertex<Fields...>::evaluate( indices, model ).value();
  }

  template<class ...Fields>
  std::complex<double> vertex( 
    lorentz_left,
    const typename Vertex<Fields...>::indices_type &indices
  ) const
  {
    return Vertex<Fields...>::evaluate( indices, model ).left();
  }

  template<class ...Fields>
  std::complex<double> vertex( 
    lorentz_right,
    const typename Vertex<Fields...>::indices_type &indices
  ) const
  {
    return Vertex<Fields...>::evaluate( indices, model ).right();
  }

  template<class ...Fields>
  std::complex<double> vertex( 
    lorentz_momentum_diff lmd_indices,
    const typename Vertex<Fields...>::indices_type &indices
  ) const
  {
    return Vertex<Fields...>::evaluate( indices, model ).value(
      lmd_indices.minuend_index, lmd_indices.subtrahend_index );
  }

  template<class ...Fields>
  std::complex<double> vertex( 
    lorentz_inverse_metric,
    const typename Vertex<Fields...>::indices_type &indices
  ) const
  {
    return Vertex<Fields...>::evaluate( indices, model ).value();
  }

  double scale( void ) const
  { return model.get_scale(); }
};

template<int NumberOfExternalIndices,
  int NumberOfExternalMomenta>
class correlation_function_context
: public generic_context
{
  const std::array<int,
    NumberOfExternalIndices> &ext_ind_;
  const std::array<Eigen::Vector4d,
    NumberOfExternalMomenta> &ext_momenta_;

public:
  correlation_function_context(
    const mass_eigenstates &m,
    const std::array<int, NumberOfExternalIndices> &ei,
    const std::array<Eigen::Vector4d, NumberOfExternalMomenta> &em
  ) : generic_context( m ),
      ext_ind_( ei ), ext_momenta_( em )
  {}

  using generic_context::mass;
  using generic_context::vertex;

  const std::array<int, NumberOfExternalIndices> &
  ext_ind( void ) const
  { return ext_ind_; }

  int ext_ind( int index ) const
  { return ext_ind_.at( index ); }
  
  const std::array<Eigen::Vector4d, NumberOfExternalMomenta> &
  ext_momenta( void ) const
  { return ext_momenta_; }
  
  Eigen::Vector4d ext_momenta( int index ) const
  { return ext_momenta_.at( index ); }
};

template<class GenericFieldMap>
class field_index_map
{
  using _1 = boost::mpl::_1;
  using pairs = typename boost::mpl::transform<
    GenericFieldMap,
    boost::fusion::pair<
      boost::mpl::first<_1>,
      field_indices<boost::mpl::second<_1>>
    >,
    boost::mpl::front_inserter<boost::mpl::vector<>>
  >::type;
public:
  using type = typename boost::mpl::apply<
    boost::mpl::unpack_args<detail::metafunction_class_fusion_map>,
    pairs
  >::type;
};

template<class GenericFieldMap>
class index_map_interface
{
  using map = typename field_index_map<
    GenericFieldMap
  >::type;
  const map &index_map_;

public:
  index_map_interface( const map &map )
  : index_map_( map ) {}

  const map &index_map( void ) const
  { return index_map_; }
};

template<
  class GenericFieldKeys,
  class GenericFieldInsertions,
  class CombinatorialFactors,
  class ColourFactors,
  template<typename> class F,
  class ...Args
>
std::array<std::complex<double>, 12> accumulate_generic( Args &&...args )
{
  using insertion_data = boost::mpl::zip_view<
    boost::mpl::vector<
      GenericFieldInsertions,
      CombinatorialFactors,
      ColourFactors
    >
  >;
  
  // TODO: make size variable
  std::array<std::complex<double>, 12> value;
  value.fill(0.0);

  boost::mpl::for_each<insertion_data>(
    detail::make_accumulate_generic_impl<
      GenericFieldKeys, F
    >( value, std::forward<Args>( args )... )
  );

  return value;
}
}
}
}

#endif
