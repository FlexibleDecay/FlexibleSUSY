// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#ifndef @ModelName@_CXXQFT_VERTICES_H
#define @ModelName@_CXXQFT_VERTICES_H

#include "concatenate.hpp"
#include "error.hpp"
#include "generic_vertices.hpp"
#include "numerics2.hpp"
#include "wrappers.hpp"

#include <boost/mpl/erase.hpp>
#include <boost/mpl/joint_view.hpp>
#include <boost/mpl/vector.hpp>

#include <complex>
#include <tuple>

#define INPUTPARAMETER(p) context.model.get_input().p
#define MODELPARAMETER(p) context.model.get_##p()
#define DERIVEDPARAMETER(p) context.model.p()
#define PHASE(p) context.model.get_##p()

namespace flexiblesusy {

namespace @ModelName@_cxx_diagrams {

template<class ...Fields>
struct VertexData;

template<class ...Fields>
class Vertex {
  using Data = VertexData<Fields...>;
public:
  using index_bounds = typename boost::mpl::fold<
    boost::mpl::vector<Fields...>,
    boost::mpl::pair<
      boost::mpl::vector<>,
      boost::mpl::vector<>
    >,
    boost::mpl::pair<
      boost::mpl::joint_view<
        boost::mpl::first<boost::mpl::_1>,
        boost::mpl::first<
           meta::index_bounds<boost::mpl::_2>
        >
      >,
      boost::mpl::joint_view<
        boost::mpl::second<boost::mpl::_1>,
        boost::mpl::second<
          meta::index_bounds<boost::mpl::_2>
        >
      >
    >
  >::type;
  using indices_type = std::array<
    int,
    detail::total_number_of_field_indices<
      boost::mpl::vector<Fields...>
    >::value
  >;
  using vertex_type = typename Data::vertex_type;

  template<int FieldIndex>
  static typename field_indices<
    typename boost::mpl::at_c<
      boost::mpl::vector<Fields...>,
      FieldIndex
    >::type
  >::type
  field_indices(const indices_type& indices)
  {
    using namespace boost::mpl;
    using fields = vector<Fields...>;

    using result_type = typename @ModelName@_cxx_diagrams::field_indices<
      typename boost::mpl::at_c<fields, FieldIndex>::type
    >::type;

    using preceeding_fields = typename erase<
      fields,
      typename advance<
        typename begin<fields>::type,
        int_<FieldIndex>
      >::type,
      typename end<fields>::type
    >::type;

    constexpr int offset = detail::total_number_of_field_indices<
      preceeding_fields
    >::value;
    constexpr int length = std::tuple_size<result_type>::value;

    result_type result_indices;
    std::copy( indices.begin() + offset,
               indices.begin() + offset + length,
               result_indices.begin() );
    return result_indices;
  }

   template <class EvaluationContext>
   static vertex_type evaluate(const indices_type& indices,
                               const EvaluationContext& context);
};

@CXXDiagrams_VertexData@

@CXXDiagrams_Vertices@

namespace detail {
@CXXDiagrams_UnitCharge@
@CXXDiagrams_StrongCoupling@
} // namespace detail

static double unit_charge(const @ModelName@_context_base& context)
{
   return -(detail::unit_charge(context).left().real() /
            @ModelName@_fields::Electron::electric_charge);
}

static double strong_coupling(const @ModelName@_context_base& context)
{
   return detail::strong_coupling(context).left().real();
}

} // namespace @ModelName@_cxx_diagrams

} // namespace flexiblesusy

#undef INPUTPARAMETER
#undef MODELPARAMETER
#undef DERIVEDPARAMETER
#undef PHASE

#endif
