// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include <cmath>

#include "@ModelName@_decays.hpp"
#include "@ModelName@_info.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "config.h"
#include "thread_pool.hpp"
#include "@ModelName@_effective_couplings_for_decays.hpp"

namespace flexiblesusy {

using namespace cxx_qft;
using namespace cxx_qft::fields;

#define CLASSNAME @ModelName@_decays

template<typename Field>
bool has_generation_index()
{
   if (Field::numberOfFieldIndices == 0 ||
       (Field::numberOfFieldIndices == 1 &&
        Field::color_rep != ParticleColorRep::singlet)) {
      return false;
   } else {
      return true;
   }
}

double two_body_phase_space_function(double mass, double MS1, double MS2) {
  return 1.0;
}
/*
const @ModelName@_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}
*/
const Decays_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
/*   decay_table.clear(); */
}

void CLASSNAME::calculate_decays(const @ModelName@_mass_eigenstates& model)
{
#ifdef ENABLE_THREADS
@callAllDecaysFunctionsInThreads@
#else
@callAllDecaysFunctions@
#endif
}

@decaysCalculationFunctions@

template<typename FieldIn, typename FieldOut1, typename FieldOut2>
double CLASSNAME::get_partial_width(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<FieldIn>::type const& indexIn,
   typename field_indices<FieldOut1>::type const& indexOut1,
   typename field_indices<FieldOut2>::type const& indexOut2
   ) const
{
   EvaluationContext context {model};

   const double mFieldIn = context.mass<FieldIn>(indexIn);

   double symmetry = 1;
   if(std::is_same<FieldOut1, FieldOut2>::value && indexOut1 == indexOut2) {
      symmetry = 1.0/2.0;
   }

   // S -> FF
   if(FieldIn::particle_type == ParticleType::scalar
      &&  FieldOut1::particle_type == ParticleType::fermion
      && FieldOut2::particle_type == ParticleType::fermion) {

   }

   // S -> VV
   if(FieldIn::particle_type == ParticleType::scalar
      &&  FieldOut1::particle_type == ParticleType::vector
      && FieldOut2::particle_type == ParticleType::vector) {

   }

   // S -> SS
   if(FieldIn::particle_type == ParticleType::scalar
      &&  FieldOut1::particle_type == ParticleType::scalar
      && FieldOut2::particle_type == ParticleType::scalar) {

   }

   // S -> SV
   if(FieldIn::particle_type == ParticleType::scalar
      &&  FieldOut1::particle_type == ParticleType::scalar
      && FieldOut2::particle_type == ParticleType::vector) {

   }
   return 1.0;
}

// -------- specializations for decays needing higher order corrections --------

// special case for Higgs -> Z Z
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@ZBosonName@,@ZBosonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@ZBosonName@>::type const& indexOut1,
   typename field_indices<@ZBosonName@>::type const& indexOut2
   ) const {

   EvaluationContext context {model};
   const double mass = context.mass<@HiggsBosonName@>(indexIn);
   const double MV = context.mass<@ZBosonName@>(indexOut1);
   const double x = Sqr(MV/mass);
   double res;
   // three-body-decays if below threshold
   if(4*x > 1.0) {
      // const auto vd = MODELPARAMETER(vd);
      // const auto vu = MODELPARAMETER(vu);
      const auto vev = 1.0; //sqrt(Sqr(vd) + Sqr(vu));
      const double sw2 = Sqr(Sin(model.ThetaW()));//1.0 - Sqr(PHYSICAL(MVWp)/PHYSICAL(MVZ));

      const double deltaV = 7.0/12.0 - 10.0/9.0 * sw2 + 40.0/27.0 * Sqr(sw2);
      const double RT = 3*(1 - 8*x + 20*Sqr(x))/sqrt(4*x - 1) * acos(0.5*(3*x - 1)/pow(x, 3.0/2.0))
                     - 0.5*(1 - x)/x * (2 - 13*x + 47*Sqr(x))
                     - 3.0/2.0 * (1 - 6*x + 4*Sqr(x))*Log(x);

      res = 3.0/(128*pow(Pi,3)) * mass/Sqr(vev) * deltaV * RT * 
        AbsSqr(effective_coupling<@HiggsBosonName@,@ZBosonName@,@ZBosonName@>(model, indexIn, indexOut1, indexOut2));
   } else {
      res = 1.0/(128*Pi * mass * Sqr(x)) * sqrt(1 - 4*x) * (1 - 4*x + 12*Sqr(x));
   } 
   return res * AbsSqr(effective_coupling<@HiggsBosonName@,@ZBosonName@,@ZBosonName@>(model, indexIn, indexOut1, indexOut2));
}

// special case for H -> W W
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@WBosonName@,@WBosonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@WBosonName@>::type const& indexOut1,
   typename field_indices<@WBosonName@>::type const& indexOut2
   ) const
{

   EvaluationContext context {model};
   const double mass = context.mass<@HiggsBosonName@>(indexIn);
   const double MV = context.mass<@WBosonName@>(indexOut1);
   const double x = Sqr(MV/mass);
   double res;
   // three-body-decays if below threshold
   if(4*x > 1.0) {
      // const auto vd = MODELPARAMETER(vd);
      // const auto vu = MODELPARAMETER(vu);
      const auto vev = 1.0; //sqrt(Sqr(vd) + Sqr(vu));
      const double sw2 = Sqr(Sin(model.ThetaW()));//1.0 - Sqr(PHYSICAL(MVWp)/PHYSICAL(MVZ));

      // deltaV is 1 for W-bosons
      const double RT = 3*(1 - 8*x + 20*Sqr(x))/sqrt(4*x - 1) * acos(0.5*(3*x - 1)/pow(x, 3.0/2.0))
                     - 0.5*(1 - x)/x * (2 - 13*x + 47*Sqr(x))
                     - 3.0/2.0 * (1 - 6*x + 4*Sqr(x))*Log(x);

      res = 3.0/(128*pow(Pi,3)) * mass/Sqr(vev) * RT;
   } else {
      res = 2.0/(128*Pi * mass * Sqr(x)) * sqrt(1 - 4*x) * (1 - 4*x + 12*Sqr(x));
   }
   return res * AbsSqr(effective_coupling<@HiggsBosonName@,@WBosonName@,@WBosonName@>(model, indexIn, indexOut1, indexOut2));
}


// special case for H -> gluon gluon
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@GluonName@,@GluonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@GluonName@>::type const& indexOut1,
   typename field_indices<@GluonName@>::type const& indexOut2
   ) const
{

   EvaluationContext context {model};
   const double mass = context.mass<@HiggsBosonName@>(indexIn);
   return 0.039788735772973836 * pow(mass, 3.0) 
    * AbsSqr(effective_coupling<@HiggsBosonName@,@GluonName@,@GluonName@>(model, indexIn, indexOut1, indexOut2));
}

// special case for H -> photon photon
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@PhotonName@,@PhotonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@PhotonName@>::type const& indexOut1,
   typename field_indices<@PhotonName@>::type const& indexOut2
   ) const
{
   EvaluationContext context {model};
   const double mass = context.mass<@HiggsBosonName@>(indexIn);
   return 0.0049735919716217296 * pow(mass, 3.0) * AbsSqr(effective_coupling<@HiggsBosonName@,@PhotonName@,@PhotonName@>(model, indexIn, indexOut1, indexOut2));
}

// special case for H -> photon Z
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@PhotonName@,@ZBosonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@PhotonName@>::type const& indexOut1,
   typename field_indices<@ZBosonName@>::type const& indexOut2
   ) const
{

   EvaluationContext context {model};
   const double mass = context.mass<@HiggsBosonName@>(indexIn);
   const double MVZ = context.mass<@ZBosonName@>(indexOut2);
   if(MVZ/mass >= 1.0)
      return 0.0;
   return 1.0/(16.0*Pi) * pow(mass * (1.0 - Sqr(MVZ/mass)), 3) 
    * AbsSqr(effective_coupling<@HiggsBosonName@,@PhotonName@,@ZBosonName@>(model, indexIn, indexOut1, indexOut2));
}
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@ZBosonName@,@PhotonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@ZBosonName@>::type const& indexOut1,
   typename field_indices<@PhotonName@>::type const& indexOut2
   ) const {
      return get_partial_width<@HiggsBosonName@,@PhotonName@,@ZBosonName@>(model, indexIn, indexOut2, indexOut1);
   }

// special case for H -> H H
template<>
double CLASSNAME::get_partial_width<@HiggsBosonName@,@HiggsBosonName@,@HiggsBosonName@>(
   @ModelName@_mass_eigenstates const& model,
   typename field_indices<@HiggsBosonName@>::type const& indexIn,
   typename field_indices<@HiggsBosonName@>::type const& indexOut1,
   typename field_indices<@HiggsBosonName@>::type const& indexOut2
   ) const
{
   EvaluationContext context {model};
   const double mass = context.mass<@HiggsBosonName@>(indexIn);
   const double MS1 = context.mass<@HiggsBosonName@>(indexOut1);
   const double MS2 = context.mass<@HiggsBosonName@>(indexOut2);
   const auto factor = 1.; //(gI1 == gI2) ? 1 : 2;

   return factor/(32*Pi * mass) * sqrt(two_body_phase_space_function(mass, MS1, MS2))
                                * AbsSqr(effective_coupling<@HiggsBosonName@,@HiggsBosonName@,@HiggsBosonName@>(model, indexIn, indexOut1, indexOut2));
   return 0.;
}

void test() {
   @ModelName@_mass_eigenstates const model;
   @ModelName@_decays cos;
   cos.get_partial_width<hh,VG,VG>(model, {}, {}, {});
}

} // namespace flexiblesusy
