// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_decays.cpp
 * @brief implementation of particle decays in the @ModelName@
 *
 * Contains the definition of @ModelName@ decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ (git commit: @FlexibleSUSYGitCommit@) and SARAH @SARAHVersion@ .
 */

#include "@ModelName@_decays.hpp"
#include "@ModelName@_info.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "concatenate.hpp"
#include "dilog.hpp"

#include "config.h"
//#include "one_loop_decay_diagrams.hpp"
#include "thread_pool.hpp"
#include "wrappers.hpp"

#include <boost/range/algorithm.hpp>

#include <cmath>
// TODO: remove before release
#include <iomanip>

namespace flexiblesusy {

#define CLASSNAME @ModelName@_decays
#define PHYSICAL(parameter) model.get_physical().parameter
#define MODELPARAMETER(parameter) model.get_##parameter()

using namespace @ModelName@_cxx_diagrams;
using effective_couplings::beta;
namespace info = @ModelName@_info;

void CLASSNAME::set_include_higher_order_corrections(bool flag)
{
   include_higher_order_corrections = flag;
}

const @ModelName@_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

void CLASSNAME::set_loop_corrections(const Decays_loop_corrections& loop_corrections_)
{
   loop_corrections = loop_corrections_;
}

const Decays_loop_corrections& CLASSNAME::get_loop_corrections() const
{
   return loop_corrections;
}

const Decays_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
#ifdef ENABLE_THREADS
@callAllDecaysFunctionsInThreads@
#else
@callAllDecaysFunctions@
#endif
}

double get_alphas(context_base const&  context)
{
   return pow(context.model.get_@gs_name@(), 2)/(4.*Pi);
}

// @todo generate names for g1, g2 based on SARAH model
double get_alpha(context_base const&  context)
{
   const double g1 = std::sqrt(3./5.)*context.model.get_g1();
   const double g2 = context.model.get_g2();
   const double e = g1*g2/std::sqrt(g1*g1+g2*g2);
   return pow(e, 2)/(4.*Pi);
}

// 1-loop BSM amplitudes

@calcAmplitudeSpecializationDefs@

// -------- specializations for decays needing higher order SM corrections --------

@create_SM_particle_usings@

namespace {

unsigned int number_of_active_flavours(double m)
{
   /*
   if (m < qedqcd.displayMbMb(){
      return 4.0;
   } else if (m < qedqcd.displayPoleMt()) {
      return 5.0;
   } else {
      return 6.0;
   }
   */
   return 5;
}

// eq. 2.7 of hep-ph/0503173
double calc_A(double b)
{
   return (1 + b * b) *
             (4. * dilog((1 - b) / (1 + b)) + 2. * dilog(-(1 - b) / (1 + b)) -
              3. * log((1 + b) / (1 - b)) * log(2 / (1 + b)) -
              2. * log((1 + b) / (1 - b)) * log(b)) -
          3. * b * log(4. / (1 - b * b)) - 4. * b * log(b);
}

// eq. 2.6 of hep-ph/0503173
double calc_DeltaH(double b)
{
   return calc_A(b)/b + 1./(16*b*b*b) * (
      3 + 34*b*b - 13*pow(b,4)) * log((1+b)/(1-b)) + 3./(8.*b*b)*(7*b*b-1);
}

// eq. 2.6 of hep-ph/0503173
double calc_DeltaAH(double b)
{
   return calc_A(b)/b + 1./(16*b) * (19 + 2*b*b + 3*pow(b,4))
      * log((1+b)/(1-b)) + 3./8.*(7-b*b);
}

// 2 and higher order
double calc_deltaqq(double alpha_s_red, double Nf)
{
   return
      // order alphas are taken into account with mass sependence somewhere alse
      0. * 17./3. * alpha_s_red 
      + (35.94 - 1.36 * Nf) * Sqr(alpha_s_red) 
      + (164.14 - 25.77 * Nf + 0.259 * Sqr(Nf)) * std::pow(alpha_s_red, 3) 
      + (39.34 - 220.9 * Nf + 9.685 * std::pow(Nf, 2) - 0.0205 * std::pow(Nf, 3)) * std::pow(alpha_s_red, 4);
}

// eq. 2.31 of hep-ph/0503172
double RT(double x) {
   BOOST_ASSERT_MSG(x<=1, "This function");
   if (is_zero(x-1)) {
      std::cout << "is zero\n"; 
      return 0.;
   } else if (1-x < 1e-6) {
      std::cout << "close zero\n"; 
      return 39*(-1 + x) + (75*std::pow(-1 + x,2))/2. - 6*std::pow(-1 + x,3);
   } else {
      std::cout << "not zero\n"; 
    return 3.*(1. - 8.*x + 20.*x*x)/std::sqrt(4.*x-1.) * std::acos((3.*x-1.)/(2.*std::pow(x, 3./2.)))
    - (1.-x)/(2.*x) * (2. - 13.*x + 47.*x*x)
    - 3./2. * (1. - 6.*x + 4.*x*x) * std::log(x);
   }
}

} // anonymous namespace

@partialWidthSpecializationDefs@

@decaysCalculationFunctions@
@partialWidthCalculationFunctions@

} // namespace flexiblesusy
