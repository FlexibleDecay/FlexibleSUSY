// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

/**
 * @file @ModelName@_decays.cpp
 * @brief implementation of particle decays in the @ModelName@
 *
 * Contains the definition of @ModelName@ decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ (git commit: @FlexibleSUSYGitCommit@) and SARAH @SARAHVersion@ .
 */

#include "@ModelName@_decays.hpp"
#include "@ModelName@_info.hpp"
#include "@ModelName@_mass_eigenstates.hpp"

#include "config.h"
#include "thread_pool.hpp"
#include "wrappers.hpp"

#include <boost/range/algorithm.hpp>

#include <cmath>

namespace flexiblesusy {

#define CLASSNAME @ModelName@_decays

#define PHYSICAL(parameter) model.get_physical().parameter
#define MODELPARAMETER(parameter) model.get_##parameter()

using namespace cxx_qft;
using effective_couplings::beta;


// returns an amplitude squared
// we need to distinguish between different combinations of scalars, fermions and vectors
// as, for examples, for S -> SS we take |A|^2 while for S - > FF we take (|A_L|^2 + |A_R|^2)


void CLASSNAME::set_include_higher_order_corrections(bool flag)
{
   include_higher_order_corrections = flag;
}

const @ModelName@_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

void CLASSNAME::set_loop_corrections(const Decays_loop_corrections& loop_corrections_)
{
   loop_corrections = loop_corrections_;
}

const Decays_loop_corrections& CLASSNAME::get_loop_corrections() const
{
   return loop_corrections;
}

const Decays_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
#ifdef ENABLE_THREADS
@callAllDecaysFunctionsInThreads@
#else
@callAllDecaysFunctions@
#endif
}


// -------- specializations for decays needing higher order corrections --------

@create_SM_particle_usings@
using ContextName = cxx_qft::@ModelName@_evaluation_context;

template<>
Decay_amplitude_SVV CLASSNAME::effective_coupling<H,G,G>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   const typename cxx_qft::field_indices<H>::type& indexIn,
   const typename cxx_qft::field_indices<G>::type& indexOut1,
   const typename cxx_qft::field_indices<G>::type& indexOut2
   ) const
{
   Decay_amplitude_type<H,G,G>::type result;
   return result;
}

template<>
Decay_amplitude_SVV CLASSNAME::effective_coupling<H,A,A>(
   const cxx_qft::@ModelName@_evaluation_context& context,
   const typename cxx_qft::field_indices<H>::type& indexIn,
   const typename cxx_qft::field_indices<A>::type& indexOut1,
   const typename cxx_qft::field_indices<A>::type& indexOut2
   ) const
{
   Decay_amplitude_type<H,A,A>::type result;
   return result;
}



// special case for H -> gluon gluon
template<>
double CLASSNAME::get_partial_width<H,G,G>(
   const @ModelName@_evaluation_context& context,
   typename field_indices<H>::type const& indexIn,
   typename field_indices<G>::type const& indexOut1,
   typename field_indices<G>::type const& indexOut2
   ) const
{

   const double mass = context.mass<H>(indexIn);
   return 0.039788735772973836 * pow(mass, 3.0);
//      * effective_coupling<H,G,G>(context, indexIn, indexOut1, indexOut2).square();
}

// special case for H -> photon photon
template<>
double CLASSNAME::get_partial_width<H,A,A>(
   const @ModelName@_evaluation_context& context,
   typename field_indices<H>::type const& indexIn,
   typename field_indices<A>::type const& indexOut1,
   typename field_indices<A>::type const& indexOut2
   ) const
{
   const double mass = context.mass<H>(indexIn);
   return 0 * 0.0049735919716217296 * pow(mass, 3.0);
      //* effective_coupling<H,A,A>(context, indexIn, indexOut1, indexOut2).square();
}




unsigned int number_of_active_flavours(double m)
{
   /*
   if (m < qedqcd.displayMbMb(){
      return 4.0;
   } else if (m < qedqcd.displayPoleMt()) {
      return 5.0;
   } else {
      return 6.0;
   }
   */
   return 5;
}

double calc_deltaqq(double alpha_s_red, double Nf) {
   return  
      5.67*alpha_s_red
      + (35.94 - 1.36*Nf)*Sqr(alpha_s_red)
      + (164.14 - 25.77*Nf + 0.26*Sqr(Nf))*std::pow(alpha_s_red, 3);
}

@include_H_to_ZZ@
@include_H_to_WW@
@include_H_to_ZA@
@include_H_to_HH@
@include_H_to_uquq@
@include_H_to_dqdq@
@include_H_to_AHAH@

@decaysCalculationFunctions@
@partialWidthCalculationFunctions@

} // namespace flexiblesusy
